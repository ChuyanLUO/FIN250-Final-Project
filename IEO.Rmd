---
title: "Final Project"
output: html_document
---
---
title: "Final Project"
output: html_document
---
```{r}
library(forecast)
library(zoo)
library(xts)
library(urca)

#IEO<-read.csv("~/Documents/Fall 2018/Forecasting/R Codes/Data Sets/IEO.csv")
IEO<-read.csv("~/Github/FIN250-Final-Project/IEO.csv")
IEO.ts <- xts(log(IEO$Adj.Close), as.Date(IEO$Date))
vol <- (diff(log(IEO.ts)))^2
plot(IEO.ts)
plot(vol)
Acf(IEO.ts)
Pacf(IEO.ts)
Acf(vol)
Pacf(vol)

train.ts <- window(IEO.ts, end = "2014-08-31")
valid.ts <- window(IEO.ts, start = "2014-09-01")
ntrain <- length(train.ts)
nvalid <- length(valid.ts)

#DF Test on Whole Data Set
df.test <- ur.df(IEO.ts,type="trend",selectlags="BIC")
print(summary(df.test))
sum <- summary(df.test)
teststat <- sum@teststat[3]
# critical value at 5 percent
critical <- sum@cval[3,2]
abs(critical)<abs(teststat) #Not reject null, series has unit root

# Arima Forecast
ArimaMod <- auto.arima(train.ts, d=1, ic="bic", seasonal = FALSE)
summary(ArimaMod)
fcast_Arima <- Arima(valid.ts, model = ArimaMod)
fcast_fitted_Arima <- xts(fcast_Arima$fitted, as.Date(IEO$Date[(ntrain+1):(ntrain+nvalid)]))
mod_fitted_Arima <- xts(ArimaMod$fitted, as.Date(IEO$Date[1:ntrain]))

print(accuracy(ArimaMod))
print(accuracy(fcast_Arima$fitted, valid.ts))

plot(IEO.ts, ylab="Price",xlab="Time",bty="l",main="Forecast of IEO Price(Arima(0,1,0))", flty=2)
lines(mod_fitted_Arima, lwd=1,col="blue")
lines(fcast_fitted_Arima, lwd=1,col="green")
```
```{r}
# Exponential Filter Forecast
# First, estimate addiive trend filter
filter.mod <- ets(train.ts, model = "AAN")
# Now, build forecasts for validation periods (uses no data there)
filter.pred <- forecast(filter.mod, h = nvalid)
# Now, build one step ahead forecasts for validation data, using estimated model
filter.onestep <- ets(valid.ts, model = filter.mod)
filter.pred.fitted <- xts(filter.pred$fitted, as.Date(IEO$Date[1:ntrain]))
filter.onestep.fitted <- xts(filter.onestep$fitted, as.Date(IEO$Date[(ntrain + 1):(ntrain + nvalid)]))
# plot all the results
plot(IEO.ts, main = "Filter Forecast (with trend)")
lines(filter.pred.fitted, lwd = 1,col="blue", lty = 2)
lines(filter.onestep.fitted,lwd = 1, col="green", lty = 2)
# check accuracy
print(accuracy(filter.pred, valid.ts))
print(accuracy(filter.onestep$fitted, valid.ts))
```
```{r}
# Naive Forecast
nALL <- length(IEO.ts)
naiveFcast.ts <- lag(IEO.ts, 1)
naiveTrain.ts <- window(naiveFcast.ts, end=("2014-08-31"))
naiveValid.ts <- window(naiveFcast.ts, start =("2014-09-01"))
# plot
plot(IEO.ts, main = 'Naive Forecast')
lines(naiveTrain.ts,col = "blue")
lines(naiveValid.ts, col = "green")
# RMSE
naive.train.res <- naiveTrain.ts-train.ts
naive.valid.res <- naiveValid.ts-valid.ts
(rmse_train <- sqrt(mean((naive.train.res)^2, na.rm =TRUE)))
(rmse_valid <- sqrt(mean((naive.valid.res)^2, na.rm =TRUE)))
```
```{r}
# perform some Diebold/Mariano tests
print("Diebold/Mariano ARIMA versus Naive")
print(dm.test(residuals(fcast_Arima),naive.valid.res))

print("Diebold/Mariano Exponential Filter versus Naive")
print(dm.test(residuals(filter.onestep),naive.valid.res))

print("Diebold/Mariano ARIMA versus Exponential Filter")
print(dm.test(residuals(fcast_Arima),residuals(filter.onestep)))
```


```{r}
# Model code for processing
# CRSP individual stock data + Index information
# Mostly for aggregating to monthly
# Clear variables

# aggregate data over months
# volume now becomes mean daily volume by $
monagg <- function(data)
{
  data <- data[data$VOL!= 0,]
  # store all data from data into temp
  temp <- tail(data,n = 1)
  m <- nrow(data)
  # these are the three lines to really pay attention to
  # Using vW index returns (changing to RET would move to IBM)
  # first find std over month
  temp$vol <- sd(data$vwretd)
  # now return over month
  temp$ret <- prod(1 + data$vwretd) - 1
  temp$m <- m # number of days
  # All these values can be negative if there are no trades 
  data$PRC <- abs(data$PRC)
  data$ASKHI <- abs(data$ASKHI)
  data$BIDLO <- abs(data$BIDLO)
  # bid/ask range (another sort of volatility estimate)
  dailyvol <- (data$ASKHI - data$BIDLO)/(0.5*(data$ASKHI + data$BIDLO))
  # remove data errors
  dailyvol[dailyvol > 1] <- 0
  dailyturn <- data$VOL/data$SHROUT
  # volatility relative to turnover
  temp$liq  <- temp$vol/mean(dailyturn)
  mturn <- mean(dailyturn)
  # set to mean if zero
  dailyturn[ dailyturn == 0] <- mturn
  temp$turn <- mean(dailyturn)
  # return monthly record
  temp
}

dateProc <- function(dateVec) 
{
  # strip out years
  year<-trunc(dateVec/10000)
  month = trunc((dateVec-year*10000)/100)
  day = trunc(dateVec-year*10000-month*100)
  strVec<-sprintf("%d-%d-%d",year,month,day)
  dateOut = as.Date(strVec)
  return(dateOut)
}


# read in raw crsp dowload - This is a long range daily series of IBMreturns
# and CRSP value weighted returns
#  It also include some volume series as well as high/low range information
allDay <- read.csv("ibmCRSP3.csv", header=TRUE, colClasses=c("numeric"))

# This is an R dataframe
# eliminate some fields that are not used
allDay$PERMNO <- NULL
allDay$NUMTRD <- NULL
allDay <- allDay[-1,]
# restrict to cases with all data fields
allDay <- allDay[complete.cases(allDay),]

# Convert CRSP date
allDay$rdate <- dateProc(allDay$date)
# set up monthly key
allDay$key <-as.numeric(format(allDay$rdate,"%Y"))*100+as.numeric(format(allDay$rdate,"%m"))

# use plyr to apply dayAgg by each date
volMonth <- ddply(allDay,.variables = "key",.fun = monagg)


# volLR <- rollmean(volMonth$vol,6, align="right",fill=mean(volMonth$vol))
# 6 month volatility model
volLR <- ma(volMonth$vol,order=6, centre=FALSE)

rv.ts  <- ts(volMonth$vol,start=c(1926,1),freq=12)
rvLR.ts <- ts(volLR, start=c(1926,1),freq=12)
ret.ts <- ts(volMonth$ret,start=c(1926,1),freq=12)
m.ts   <- ts(volMonth$m,start=c(1926,1),freq=12)

rvtrain.ts <- window(rv.ts,end=c(2008,10))
rvtest.ts  <- window(rv.ts,start=c(2008,11))



# Several AR models with extensions (ARMAX models)

lagvol = cbind(rv.ts,lag(rv.ts,-1,na.pad=TRUE),lag(rvLR.ts,-2,na.pad=TRUE), lag((ret.ts),-1,na.pad=TRUE), ret.ts, m.ts)
colnames(lagvol) <- c("vol", "volL1", "volL2", "retL", "ret", "m")

lagvol <- window(lagvol,end=c(2016,12))

lagvolTrain <- window(lagvol,end=c(1990,12))
lagvolValid <- window(lagvol,start=c(1991,1))

# Use basic model + leverage effect term
volTrain.mod <- lm(vol ~ volL1 + volL2 + retL,data=lagvolTrain)
print(summary(volTrain.mod))

# Build valid sample volatility forecast
vol.fcast <- predict( volTrain.mod, lagvolValid)
# Adjust this to monthly value (daily -> monthly)
vol.fcast <- sqrt(lagvolValid[,6])*vol.fcast
# set for 10 percent annual standard deviation
target <- 0.10/sqrt(12)
# now portfolio weight vector
weight <- target/vol.fcast
# constant portfolio benchmark
mweight <- mean(weight)

# dynamic monthly portfolio (assuming 3 percent/year interest)
pret  <-  lagvolValid[,5]*weight  + 0.03/12.*(1-weight)
pretConstant <-  lagvolValid[,5]*mweight + 0.03/12 *(1-mweight)
pretEquity   <-  lagvolValid[,5]* 1

# Volatility for portfolios (adjust for days of the month)
pstd  <-  sqrt(lagvolValid[,6])*lagvolValid[,1]*weight
pstdConstant <-  sqrt(lagvolValid[,6])*lagvolValid[,1]*mweight
pstdEquity   <-  sqrt(lagvolValid[,6])*lagvolValid[,1]*1

# Convert to annual values (like target)
pstd         <- sqrt(12)*pstd
pstdConstant <- sqrt(12)*pstdConstant
pstdEquity   <- sqrt(12)*pstdEquity

# Look at the variability of returns around volatility targets
print("Standard deviations and sd(standard deviations)")
print(cbind(mean(pstd),sd(pstd)))
print(cbind(mean(pstdConstant),sd(pstdConstant)))
print(cbind(mean(pstdEquity),sd(pstdEquity)))
 
# General mean and return for returns (annualized)           
print("mean and standard deviations for returns (annualized)")            
print(cbind(12*mean(pret),sqrt(12)*sd(pret)))
print(cbind(12*mean(pretConstant),sqrt(12)*sd(pretConstant)))
print(cbind(12*mean(pretEquity),sqrt(12)*sd(pretEquity)))

# Sharpe ratios
print("Sharpe ratios (annualized)")
print( (12*mean(pret)-0.03)/( sqrt(12)*sd(pret)))
print( (12*mean(pretConstant)-0.03)/( sqrt(12)*sd(pretConstant)))       
print( (12*mean(pretEquity)-0.03)/( sqrt(12)*sd(pretEquity)))       

plot(pstd,ylim=c(0,0.8),xlab="year",ylab="annualized std")
lines(pstdEquity,col="red")
grid()
```
